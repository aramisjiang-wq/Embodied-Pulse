# Trae AI助手项目规则

**文档版本**: v1.0
**创建日期**: 2026-01-26
**适用范围**: Trae AI助手参与的所有项目开发

---

## 📋 目录

1. [核心原则](#核心原则)
2. [项目目录结构](#项目目录结构)
3. [文档管理规范](#文档管理规范)
4. [开发流程准则](#开发流程准则)
5. [技术栈选型原则](#技术栈选型原则)
6. [安全准则](#安全准则)
7. [性能优化原则](#性能优化原则)
8. [代码开发规范](#代码开发规范)
9. [UI设计规范](#ui设计规范)
10. [颜色使用规范](#颜色使用规范)
11. [API开发规范](#api开发规范)
12. [测试规范](#测试规范)
13. [最佳实践](#最佳实践)

---

## 核心原则

### 1. 代码管理
- **永远从GitHub拉取代码**：任何修复建议必须包含 `git pull origin main`
- **永远使用标准脚本**：推荐使用标准脚本，禁止手动执行修复步骤
- **永远先诊断后修复**：遇到问题先执行诊断，根据结果制定方案
- **永远记录操作**：记录所有建议的操作和预期结果
- **永远验证修复**：修复后必须验证，提供验证命令

### 2. 文档管理
- **文档命名规范**：`<文档类型>_<产品名称>_<YYYYMMDD>.md`
- **版本控制**：文档更新时同步更新版本号和日期
- **相对路径**：文档中的链接必须使用相对路径，禁止绝对路径
- **功能说明组织**：按「产品端 → 页面 → 区块 → 功能点」结构组织
- **开发记录合并**：同一目的的开发记录应合并，过期的应归档或删除
- **文档完整性**：每个文档必须包含版本号、创建日期、最后更新日期、维护人

### 3. 沟通记录规范
- **必须包含**：业务逻辑图、沟通记录板块映射、沟通记录总览、详细沟通记录
- **板块映射表**：沟通编号、沟通主题、涉及板块、调整内容
- **沟通记录总览表**：沟通编号、沟通日期、沟通主题、状态（✅ 已完成 / 🔄 讨论中）
- **详细沟通记录**：沟通日期、沟通目的、涉及板块、沟通内容、沟通总结、涉及文件、状态
- **同步更新**：每次添加新沟通记录时，必须同步更新：沟通记录板块映射表、沟通记录总览表、文档版本号
- **命名规范**：`沟通记录_<产品名称>_<YYYYMMDD>.md`
- **版本号格式**：vX.Y（X为主版本号，Y为次版本号）

---

## 项目目录结构

### 标准目录结构

```
Project/
├── data/                          # 原始数据目录
│   └── YYYYMMDD/                  # 按日期组织的数据
├── scripts/                       # 所有脚本目录（根目录不允许有脚本文件）
│   ├── data_analysis/             # 数据分析脚本
│   ├── report_generation/         # 报告生成脚本
│   ├── data_processing/           # 数据处理脚本和输出
│   └── utils/                     # 工具脚本
├── docs/                          # 文档目录
│   ├── 00-文档索引/               # 文档导航和索引
│   ├── 01-项目规划/               # 项目立项、需求、规划
│   ├── 02-产品设计/               # PRD、功能设计、交互设计
│   ├── 03-技术架构/               # 系统架构、技术方案、API文档
│   ├── 04-开发记录/               # 开发日志、代码规范、技术债务
│   ├── 05-测试报告/               # 测试记录、性能测试、安全测试
│   ├── 06-部署运维/               # 部署指南、运维手册、故障处理
│   ├── 07-评估总结/               # 项目评估、总结报告
│   ├── 08-发版记录/               # 版本发布、更新日志
│   ├── 09-沟通记录/               # 会议记录、沟通文档
│   ├── 10-规范模板/               # 文档规范、模板文件
│   └── 11-其他文档/               # 其他临时文档
├── backend/                       # 后端项目
│   ├── src/                       # 源代码
│   ├── prisma/                    # 数据库schema
│   └── package.json               # 依赖配置
└── frontend/                      # 前端项目
    ├── src/                       # 源代码
    ├── public/                    # 静态资源
    └── package.json               # 依赖配置
```

### 文件限制规则
- **根目录不允许有脚本文件**：所有脚本必须放在scripts目录下
- **禁止重复文件**：同一功能只能有一个实现文件
- **模块解耦**：每个模块职责单一，模块间依赖最小化

---

## 文档管理规范

### 文档分类原则

按照**文档的生命周期和用途**进行分类：

1. **按项目阶段分类**：反映项目的自然演进过程
2. **按文档类型分类**：便于快速定位和查找
3. **按范围分类**：区分通用文档和项目特定文档
4. **避免过度细分**：保持分类简洁实用
5. **模块解耦化**：每个文档只负责一个明确的功能或主题

### 文档命名规范

**通用格式**：`<文档类型>_<产品名称>_<YYYYMMDD>.md`

**示例**：
- PRD文档：`PRD_Embodied_Pulse_20260126.md`
- 技术方案：`技术方案设计_Embodied_Pulse_20260126.md`
- 开发记录：`开发记录_Embodied_Pulse_20260126.md`

### 文档版本控制

**版本号格式**：vX.Y（X为主版本号，Y为次版本号）

**更新规则**：
- 主版本号（X）：重大架构变更、功能重构
- 次版本号（Y）：功能新增、Bug修复、文档优化

**必须包含的元数据**：
```markdown
**文档版本**: vX.Y
**创建日期**: YYYY-MM-DD
**最后更新**: YYYY-MM-DD
**适用范围**: [通用] / [Web后端] / [数据分析]
**维护人**: AI助手团队
```

### 文档自动更新逻辑

**触发场景**：
1. 新增功能开发完成
2. Bug修复完成
3. 性能优化完成
4. 需求变更或调整
5. 技术方案调整

**自动更新内容**：
- 更新文档版本号
- 更新最后更新日期
- 更新相关功能状态
- 同步更新关联文档的引用

---

## 开发流程准则

### 开发流程

```
┌─────────────────────────────────────────────────────────────┐
│                        开发流程准则                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  标准流程：需求分析 → 产品设计 → 技术设计 → MVP开发 → 部署上线 → 迭代优化 → 运维监控      │
│                                                             │
│  实施逻辑：框架搭建 → 数据层设计 → 页面开发 → 功能实现 → 测试验证 → 性能优化 → 部署上线 → 监控运维      │
│                                                             │
│  开发原则：总（框架搭建）→ 分（逐页开发）→ 总（整合优化）      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 开发顺序原则

**核心原则**

```
先把用户端做完，再做管理端，然后先把后端做完，再做前端，然后校验前后端还有数据库的一致性，校验用户端和管理端的一致性
```

**必须遵循**：
- ✅ 严格按照用户端→管理端的顺序开发
- ✅ 严格按照后端→前端的顺序开发
- ✅ 在开发完成后进行前后端一致性校验
- ✅ 在开发完成后进行用户端与管理端一致性校验
- ✅ 每个阶段完成后必须进行独立测试
- ✅ 及时记录开发过程中发现的问题

**禁止行为**：
- ❌ 跳过开发顺序，随意开发
- ❌ 在用户端未完成时开发管理端
- ❌ 在后端未完成时开发前端
- ❌ 不进行一致性校验就认为开发完成
- ❌ 混乱开发，不遵循既定顺序

### 需求分析阶段

**必须执行**：
- ✅ 帮助用户进行需求调研，使用"当你做X时，最大阻碍是什么？"的格式
- ✅ 使用需求真伪判断三问法过滤伪需求（高频性、繁琐性、容错性）
- ✅ 使用RICE评分法对需求优先级排序：RICE = (影响力 × 触达用户 × 确定性) ÷ 成本
- ✅ 使用5W2H方法描述每个需求
- ✅ 为每个需求定义明确的验收标准（可测试、可衡量）
- ✅ 推荐访谈3-5个典型用户（新手、资深、Leader）
- ✅ 聚焦核心痛点，避免花哨功能

**禁止行为**：
- ❌ 直接问用户"你想要什么功能？"
- ❌ 凭空想象功能，不进行用户调研就开发
- ❌ 评分主观性强，缺乏依据
- ❌ 需求描述不清晰、缺少验收标准
- ❌ 避免追求完美，导致迟迟无法交付

### 产品设计阶段

**必须执行**：
- ✅ 帮助用户编写PRD文档，包含：产品目标、用户故事、功能规格、验收标准
- ✅ 确保验收标准是可测试、可衡量的
- ✅ 添加用户场景和流程图
- ✅ 划分功能模块（用户端、管理端、后台）
- ✅ 定义模块之间的关系和接口
- ✅ 设计数据流转和状态管理
- ✅ 设计核心页面（首页、详情页、列表页）
- ✅ 设计交互流程和跳转逻辑
- ✅ 框架图谱和架构图必须使用md格式（ASCII art），不要使用mermaid格式

**禁止行为**：
- ❌ PRD写不好、验收标准不明确
- ❌ 模块划分不合理、接口定义不清
- ❌ 原型不完整、交互逻辑不清

### 技术设计阶段

**必须执行**：
- ✅ 帮助用户进行技术选型，考虑学习成本、社区支持、性能要求
- ✅ 对比2-3个备选方案
- ✅ 推荐成熟稳定的技术，避免过度追求新技术
- ✅ 设计系统整体架构（分层架构）
- ✅ 画出架构图（用户层、应用层、数据层）
- ✅ 定义各层职责和接口
- ✅ 识别可复用的模块和组件
- ✅ 设计模块接口和依赖关系
- ✅ 定义模块的输入输出
- ✅ 编写SPEC文档，定义API接口规范（URL、方法、参数、响应）
- ✅ 设计数据库表结构
- ✅ 定义数据模型和关系

**禁止行为**：
- ❌ 技术选型不当、过度追求新技术
- ❌ 架构设计不合理、扩展性差
- ❌ 模块耦合度高、复用性差
- ❌ SPEC写不好、技术可行性不清

### MVP开发阶段

**必须执行**：
- ✅ 帮助用户搭建本地开发环境（安装开发工具、配置虚拟环境、安装依赖包）
- ✅ 按优先级开发核心功能
- ✅ 使用模块化设计，复用组件
- ✅ 遵循代码规范
- ✅ 使用Git分支管理（main/dev/feature）
- ✅ 遵循Commit Message规范
- ✅ 定期推送到GitHub
- ✅ 编写单元测试用例
- ✅ 测试核心功能和边界情况
- ✅ 确保测试覆盖率>80%
- ✅ 本地运行应用，测试所有核心功能
- ✅ 验证验收标准
- ✅ 从小功能入手，快速验证（MVP）

**禁止行为**：
- ❌ 环境配置错误、依赖冲突
- ❌ 开发效率低、代码质量差
- ❌ 代码冲突、提交不规范
- ❌ 测试用例不完整、覆盖率低
- ❌ 功能不完整、性能不达标
- ❌ 一次性做太多，分阶段迭代

### 首次部署阶段

**必须执行**：
- ✅ 帮助用户准备服务器（购买云服务器、配置防火墙、安装必要软件）
- ✅ 克隆代码到服务器
- ✅ 安装依赖包
- ✅ 配置生产环境（.env文件）
- ✅ 配置反向代理
- ✅ 配置静态文件服务
- ✅ 配置压缩
- ✅ 申请SSL证书
- ✅ 配置HTTPS
- ✅ 配置HTTP自动跳转HTTPS
- ✅ 访问生产环境URL，测试所有核心功能
- ✅ 检查日志是否有错误

**禁止行为**：
- ❌ 服务器配置错误、安全漏洞
- ❌ 依赖冲突、环境配置错误
- ❌ 反向代理配置错误
- ❌ SSL证书申请失败、HTTPS配置错误
- ❌ 功能异常、性能问题

### 迭代优化阶段

**必须执行**：
- ✅ 帮助用户监控用户行为数据
- ✅ 收集用户反馈（问卷、访谈）
- ✅ 识别用户痛点
- ✅ 使用性能分析工具
- ✅ 识别性能瓶颈（数据库、代码、网络）
- ✅ 优化数据库查询（添加索引、优化SQL）
- ✅ 根据反馈优先级排序功能
- ✅ 使用A/B测试验证新功能
- ✅ 小步迭代，快速验证
- ✅ 进行安全审计
- ✅ 修复安全漏洞（XSS、CSRF、SQL注入）
- ✅ 加强身份认证和授权
- ✅ 每次迭代都基于数据反馈

**禁止行为**：
- ❌ 反馈不真实、样本量不足
- ❌ 优化方向错误、效果不明显
- ❌ 迭代方向错误、功能堆砌
- ❌ 安全漏洞未发现、修复不彻底
- ❌ 凭感觉优化，不基于数据决策

### 运维监控阶段

**必须执行**：
- ✅ 帮助用户选择监控工具（Prometheus、Grafana）
- ✅ 配置监控指标（CPU、内存、磁盘、网络）
- ✅ 配置应用监控（响应时间、错误率、QPS）
- ✅ 配置日志收集（ELK Stack）
- ✅ 配置日志格式和级别
- ✅ 分析错误日志和访问日志
- ✅ 建立故障排查流程
- ✅ 使用监控工具定位问题
- ✅ 分析日志查找原因
- ✅ 配置自动备份（数据库、文件）
- ✅ 定期测试备份恢复
- ✅ 备份到多个位置（本地、云存储）

**禁止行为**：
- ❌ 监控指标不全、告警配置错误
- ❌ 日志不完整、分析困难
- ❌ 故障定位慢、修复不及时
- ❌ 备份失败、恢复测试不足

---

## 技术栈选型原则

**必须执行**：
- ✅ 根据项目需求推荐合适的技术栈
- ✅ 考虑团队技术背景和学习成本
- ✅ 推荐有活跃社区和丰富文档的技术
- ✅ 推荐生态完善的技术（有丰富的第三方库和工具）
- ✅ 推荐代码清晰、易于理解和修改的技术
- ✅ 对比2-3个备选方案，说明优缺点
- ✅ 推荐成熟稳定的技术，避免过度追求新技术
- ✅ 根据适用性、学习成本、社区支持、生态完善、可维护性等维度进行评估

**禁止行为**：
- ❌ 推荐不适合项目需求的技术
- ❌ 忽略团队技术背景和学习成本
- ❌ 推荐社区不活跃、文档不完善的技术
- ❌ 推荐生态不完善的技术
- ❌ 推荐过于复杂或小众的技术
- ❌ 过度追求新技术

### 推荐技术栈

```
┌─────────────────────────────────────────────────────────────────────┐
│                        技术栈选型原则                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                             │
│  前端: React + TypeScript  后端: Node.js + Express                     │
│  数据库: PostgreSQL  AI: OpenAI GPT-4 API  支付: Stripe               │
│                                                             │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 安全准则

**必须执行**：
- ✅ 帮助用户避免SQL注入（使用参数化查询）
- ✅ 帮助用户避免XSS攻击（对用户输入进行转义）
- ✅ 帮助用户避免CSRF攻击（使用CSRF Token）
- ✅ 帮助用户加密存储敏感数据（密码、密钥）
- ✅ 推荐使用HTTPS传输数据
- ✅ 帮助用户实现身份认证和授权
- ✅ 推荐使用安全的密码哈希算法（如bcrypt）
- ✅ 帮助用户配置安全的会话管理
- ✅ 推荐使用安全的API认证方式（如JWT）
- ✅ 帮助用户实现API访问频率限制
- ✅ 推荐使用安全的文件上传方式
- ✅ 帮助用户配置安全的数据库访问

**禁止行为**：
- ❌ 建议使用不安全的密码存储方式（如明文存储）
- ❌ 忽略输入验证和输出编码
- ❌ 忽略会话安全
- ❌ 使用不安全的API认证方式
- ❌ 忽略文件上传安全
- ❌ 忽略数据库安全

---

## 性能优化原则

**必须执行**：
- ✅ 帮助用户识别性能瓶颈（前端、后端、数据库、网络）
- ✅ 推荐前端优化方案（代码压缩、图片优化、缓存策略）
- ✅ 推荐后端优化方案（算法优化、并发处理、缓存机制）
- ✅ 推荐数据库优化方案（索引优化、查询优化、连接池）
- ✅ 帮助用户实现CDN加速
- ✅ 推荐使用缓存技术（Redis、Memcached）
- ✅ 帮助用户实现数据库读写分离
- ✅ 推荐使用异步处理（消息队列）
- ✅ 帮助用户实现负载均衡
- ✅ 推荐使用性能监控工具
- ✅ 帮助用户进行压力测试
- ✅ 推荐使用性能分析工具

**禁止行为**：
- ❌ 忽略性能监控和分析
- ❌ 过度优化，不考虑成本效益
- ❌ 忽略缓存策略
- ❌ 忽略数据库优化
- ❌ 忽略前端性能优化

---

## 代码开发规范

### 1. 代码风格

#### TypeScript规范
- 使用TypeScript编写所有代码
- 严格类型检查
- 避免使用any类型
- 使用接口定义数据结构

#### 命名规范
- 变量：camelCase
- 常量：UPPER_SNAKE_CASE
- 函数：camelCase
- 类：PascalCase
- 接口：PascalCase，以I开头

#### 注释规范
- 函数和复杂逻辑必须添加注释
- 使用JSDoc格式
- 注释要清晰简洁

### 2. 代码组织

#### 文件结构
```
src/
├── components/     # 公共组件
├── pages/         # 页面组件
├── services/      # 业务逻辑
├── utils/         # 工具函数
├── types/         # 类型定义
├── hooks/         # 自定义Hooks
└── constants/     # 常量定义
```

#### 组件规范
- 单一职责原则
- 组件大小适中（<300行）
- 使用Props传递数据
- 使用状态管理共享数据

### 3. 错误处理

#### 错误处理原则
- 所有异步操作必须处理错误
- 使用try-catch捕获错误
- 提供友好的错误提示
- 记录错误日志

#### 错误处理示例
```typescript
try {
  const result = await fetchData();
  return result;
} catch (error) {
  console.error('获取数据失败:', error);
  throw new Error('获取数据失败，请稍后重试');
}
```

---

## UI设计规范

### 1. 设计原则

#### 核心原则
- **用户优先**: 以用户需求为中心
- **简洁明了**: 界面简洁，易于理解
- **一致性**: 保持设计风格一致
- **响应式**: 适配不同设备

#### 设计目标
- 提供良好的用户体验
- 降低学习成本
- 提高操作效率
- 增强用户粘性

### 2. 组件设计

#### 组件规范
- 使用Ant Design组件库
- 自定义组件遵循设计规范
- 组件可复用
- 组件可配置

#### 组件示例
```tsx
import { Button, Card, Tag } from 'antd';

const MyComponent = ({ title, description, tags }) => (
  <Card
    title={title}
    extra={<Tag color="blue">标签</Tag>}
  >
    <p>{description}</p>
  </Card>
);
```

### 3. 响应式设计

#### 断点设置
- 移动端：<768px
- 平板端：768px-1024px
- 桌面端：>1024px

#### 响应式实现
```tsx
import { useBreakpoint } from 'antd';

const MyComponent = () => {
  const { xs, sm, md, lg, xl } = useBreakpoint();

  return (
    <div style={{ padding: xs ? '8px' : '16px' }}>
      内容
    </div>
  );
};
```

---

## 颜色使用规范

### 1. 核心规则

#### 禁止使用紫色的场景

**用户端和管理端，所有Banner或按钮的背景不允许有任何紫色。**

#### 禁止示例 ❌
- Banner背景使用紫色渐变
- 按钮背景使用紫色
- 卡片背景使用紫色
- 任何UI元素的背景色使用紫色

#### 允许使用紫色的场景 ✅
- **图标颜色**可以使用紫色
- **标签（Tag）颜色**可以使用紫色
- 文字颜色可以使用紫色（非背景）

### 2. 替代方案

#### 推荐颜色方案

当需要替换紫色背景时，推荐使用：

1. **蓝色渐变**（主要推荐）
   ```css
   background: linear-gradient(135deg, #1890ff 0%, #096dd9 100%);
   ```

2. **其他可选颜色**
   - 青色渐变：`linear-gradient(135deg, #13c2c2 0%, #08979c 100%)`
   - 绿色渐变：`linear-gradient(135deg, #52c41a 0%, #389e0d 100%)`
   - 橙色渐变：`linear-gradient(135deg, #fa8c16 0%, #d46b08 100%)`

### 3. 检查清单

在开发或修改代码时，请检查：

- [ ] Banner背景是否使用了紫色？
- [ ] 按钮背景是否使用了紫色？
- [ ] 卡片背景是否使用了紫色？
- [ ] 其他UI元素背景是否使用了紫色？
- [ ] 图标和标签的紫色使用是否符合规范？

### 4. 常见紫色色值

需要避免在背景中使用的紫色色值：
- `#667eea`
- `#764ba2`
- `purple`
- `#722ed1`
- 任何包含紫色的渐变

### 5. 符合规范的示例

#### 图标使用紫色 ✅
```tsx
<GithubOutlined style={{ color: '#722ed1' }} />
```

#### 标签使用紫色 ✅
```tsx
<Tag color="purple">视频</Tag>
```

#### 按钮背景使用蓝色 ✅
```tsx
<Button
  style={{
    background: 'linear-gradient(135deg, #1890ff 0%, #096dd9 100%)'
  }}
>
  提交
</Button>
```

### 6. 不符合规范的示例

#### Banner背景使用紫色 ❌
```tsx
<div style={{
  background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'
}}>
  Banner内容
</div>
```

#### 按钮背景使用紫色 ❌
```tsx
<Button style={{ background: '#722ed1' }}>
  点击
</Button>
```

### 7. 注意事项

1. 此规则适用于**所有用户端和管理端页面**
2. 规则优先级为**高**，必须严格遵守
3. 在代码审查时，需要特别检查颜色使用
4. 如有疑问，请参考本文档或咨询设计团队

---

## API开发规范

### 1. API设计原则

#### RESTful API规范
- 使用HTTP方法：GET、POST、PUT、DELETE
- 使用名词表示资源
- 使用复数形式：/users、/posts
- 使用版本号：/api/v1/

#### URL设计
```
GET    /api/v1/users          # 获取用户列表
GET    /api/v1/users/:id      # 获取用户详情
POST   /api/v1/users          # 创建用户
PUT    /api/v1/users/:id      # 更新用户
DELETE /api/v1/users/:id      # 删除用户
```

### 2. 响应格式

#### 成功响应
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "id": 1,
    "name": "用户名"
  },
  "timestamp": 1234567890
}
```

#### 错误响应
```json
{
  "code": 400,
  "message": "参数错误",
  "error": "用户名不能为空",
  "timestamp": 1234567890
}
```

### 3. 认证与授权

#### JWT认证
```typescript
// 生成Token
const token = jwt.sign(
  { userId: user.id, role: user.role },
  process.env.JWT_SECRET,
  { expiresIn: '7d' }
);

// 验证Token
const decoded = jwt.verify(token, process.env.JWT_SECRET);
```

#### 权限验证
```typescript
function checkPermission(requiredRole: string) {
  return (req, res, next) => {
    const userRole = req.user.role;
    if (userRole !== 'super_admin' && userRole !== requiredRole) {
      return res.status(403).json({ error: 'Permission denied' });
    }
    next();
  };
}
```

---

## 测试规范

### 1. 测试类型

#### 单元测试
- 测试单个函数或组件
- 使用Jest或Vitest
- 覆盖率要求：>80%

#### 集成测试
- 测试多个模块的交互
- 测试API接口
- 测试数据库操作

#### 端到端测试
- 测试完整的用户流程
- 使用Cypress或Playwright
- 覆盖核心业务流程

### 2. 测试编写规范

#### 测试命名
```typescript
describe('UserService', () => {
  describe('createUser', () => {
    it('should create a new user', async () => {
      // 测试代码
    });
  });
});
```

#### 测试覆盖率
- 单元测试覆盖率：>80%
- 集成测试覆盖率：>70%
- 端到端测试：覆盖核心业务流程

---

## 最佳实践

### 1. 开发效率

#### 使用TodoWrite工具
- 对于复杂任务，使用TodoWrite工具规划和跟踪进度
- 及时更新任务状态
- 完成任务后立即标记为completed

#### 代码搜索
- 优先使用SearchCodebase工具搜索代码
- 避免使用Grep工具进行代码搜索
- 使用Glob工具查找文件

### 2. 代码质量

#### 代码审查
- 提交代码前进行自我审查
- 检查代码是否符合规范
- 确保没有明显的bug

#### 测试
- 编写单元测试
- 运行测试确保代码质量
- 确保测试覆盖率达标

### 3. 文档维护

#### 及时更新
- 代码变更后及时更新文档
- 保持文档与代码同步
- 记录重要的设计决策

#### 文档质量
- 文档要清晰易懂
- 提供必要的示例
- 保持文档结构清晰

### 4. 团队协作

#### 沟通
- 及时沟通问题和进展
- 使用清晰的语言描述问题
- 提供必要的上下文信息

#### 代码共享
- 定期推送代码到GitHub
- 使用有意义的commit message
- 及时处理代码冲突

---

## 附录

### A. 常用命令

#### Git命令
```bash
git pull origin main
git add .
git commit -m "feat: 添加新功能"
git push origin feature-branch
```

#### 开发服务器
```bash
# 后端
cd backend && npm run dev

# 前端
cd frontend && npm run dev
```

### B. 常用工具

#### 代码搜索
- SearchCodebase：搜索代码内容
- Grep：搜索文件内容
- Glob：查找文件

#### 文件操作
- Read：读取文件
- Write：写入文件
- Edit：编辑文件

### C. 常见问题

#### Q: 如何处理数据库迁移？
A: 使用Prisma迁移工具，避免直接修改数据库。

#### Q: 如何处理API错误？
A: 使用统一的错误处理中间件，返回标准化的错误响应。

#### Q: 如何优化前端性能？
A: 使用代码分割、懒加载、缓存策略等技术。

---

**文档版本**: v1.0
**创建日期**: 2026-01-26
**最后更新**: 2026-01-26
**维护人**: AI助手团队

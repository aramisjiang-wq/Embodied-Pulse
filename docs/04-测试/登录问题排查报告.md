# 登录问题排查报告

**排查时间**: 2026-02-17  
**问题描述**: 强制登录 + 登录状态不保持

---

## 问题一：强制登录问题

### 根本原因

页面级别的登录检查过于激进，在 `authStore` 初始化完成之前就执行了跳转。

### 问题代码位置

| 文件 | 位置 | 问题代码 |
|------|------|----------|
| `src/app/favorites/page.tsx` | 第63行 useEffect | `if (!user) { router.push('/login'); }` |
| `src/app/subscriptions/page.tsx` | 第65行 useEffect | `if (!user) { router.push('/login'); }` |
| `src/app/subscriptions-new/page.tsx` | 第48行 useEffect | `if (!user) { router.push('/login'); }` |

### 问题机制

1. `authStore` 的 `hydrated` 初始值是 `false`
2. 页面首次渲染时，`user` 是 `null`
3. `useEffect` 立即执行，发现 `!user` 就跳转登录
4. 即使 `AuthProvider` 后来初始化了状态，页面已经跳走了

### 验证结论

- `client.ts` 的 401 处理修改是正确的（只对 admin 页面做重定向）
- 但页面级别的检查先于 API 调用执行，导致问题

---

## 问题二：登录状态不保持问题

### 根本原因

`authStore` 初始化时机问题，页面组件的 `useEffect` 可能在 `initialize()` 完成之前执行。

### 问题代码位置

- `src/store/authStore.ts` - initialize 函数
- `src/components/AuthProvider.tsx` - useEffect 调用 initialize

### 问题机制

1. 登录成功后，`setToken` 会设置 `hydrated: true`
2. 页面刷新后，`authStore` 重置为初始状态（`hydrated: false`, `token: null`）
3. `AuthProvider` 调用 `initialize()`
4. `initialize()` 从 localStorage 读取 token 并设置状态
5. **但是**，如果页面组件的 `useEffect` 在 `initialize()` 完成之前执行，会看到 `user=null` 并触发跳转

### 关键时序问题

```
页面加载
    ↓
AuthProvider useEffect → initialize() 开始
    ↓                          ↓
页面组件 useEffect 执行    initialize() 完成
    ↓                          ↓
检查 user=null          设置 user/token
    ↓
跳转登录页 ← 问题发生
```

---

## 其他检查结果

### 无问题的部分

1. **middleware.ts** - 只匹配 `/subscriptions` 路径，且不做任何重定向
2. **client.ts 401 处理** - 已正确修改，只对 admin 页面做重定向
3. **token 存储逻辑** - 正确使用 `user_token` 和 `admin_token` 分离存储
4. **登录流程** - login/page.tsx 正确保存 token 到 localStorage

### 相关文件清单

```
src/
├── store/
│   └── authStore.ts          # 认证状态管理
├── components/
│   ├── AuthProvider.tsx      # 认证初始化
│   ├── Header.tsx            # 头部组件（显示登录状态）
│   └── GlobalSidebar.tsx     # 侧边栏
├── lib/api/
│   ├── client.ts             # API 客户端（401处理）
│   ├── auth.ts               # 认证API
│   └── cached-client.ts      # 缓存客户端
├── app/
│   ├── login/page.tsx        # 登录页
│   ├── favorites/page.tsx    # 收藏页（需修复）
│   ├── subscriptions/page.tsx        # 订阅页（需修复）
│   ├── subscriptions-new/page.tsx    # 内容订阅页（需修复）
│   ├── subscriptions/[id]/page.tsx   # 订阅详情页
│   └── admin/layout.tsx      # 管理端布局（正常）
└── middleware.ts             # Next.js 中间件（正常）
```

---

## 修复方案

### 方案一：页面级别修复（推荐）

在需要登录的页面中，等待 `hydrated=true` 后再检查用户状态：

```typescript
// 修改前
useEffect(() => {
  if (!user) {
    router.push('/login');
  }
}, [user]);

// 修改后
useEffect(() => {
  if (hydrated && !user) {
    router.push('/login');
  }
}, [hydrated, user]);
```

### 方案二：authStore 持久化

使用 `zustand/middleware` 的 `persist` 中间件，自动持久化状态：

```typescript
import { persist } from 'zustand/middleware';

export const useAuthStore = create(
  persist<AuthState>(
    (set, get) => ({ /* ... */ }),
    {
      name: 'auth-storage',
      partialize: (state) => ({ 
        user: state.user, 
        token: state.token, 
        isAdmin: state.isAdmin 
      }),
    }
  )
);
```

### 推荐修复顺序

1. 先修复页面级别的 `hydrated` 检查（快速修复）
2. 再考虑 authStore 持久化（长期优化）

---

## 结论

两个问题的根本原因都是**状态初始化时序问题**：

1. 页面组件在 `authStore` 初始化完成前就检查了 `user` 状态
2. 导致误判为未登录并跳转

修复核心：确保页面组件等待 `hydrated=true` 后再执行登录检查。
